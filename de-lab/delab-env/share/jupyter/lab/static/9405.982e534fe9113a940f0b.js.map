{"version":3,"sources":["webpack://@jupyterlab/application-top/./node_modules/memoize-one/dist/memoize-one.esm.js","webpack://@jupyterlab/application-top/./node_modules/react-window/dist/index.esm.js"],"names":["safeIsNaN","Number","isNaN","ponyfill","value","isEqual","first","second","areInputsEqual","newInputs","lastInputs","length","i","memoizeOne","resultFn","lastThis","lastArgs","lastResult","calledOnce","memoized","newArgs","_i","arguments","this","apply","hasNativePerformanceNow","performance","now","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","tick","call","requestAnimationFrame","size","getScrollbarSize","recalculate","div","document","createElement","style","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","cachedRTLResult","getRTLOffsetType","outerDiv","outerStyle","direction","innerDiv","innerStyle","scrollLeft","IS_SCROLLING_DEBOUNCE_INTERVAL","defaultItemKey","_ref","columnIndex","data","rowIndex","devWarningsOverscanCount","devWarningsOverscanRowsColumnsCount","devWarningsTagName","createGridComponent","_ref2","_class","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","Grid","props","_this","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","_this$props","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","key","hasOwnProperty","_offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","_event$currentTarget","currentTarget","clientHeight","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","_proto","prototype","scrollTo","_ref3","scrollToItem","_ref4","_ref4$align","align","_this$props2","columnCount","rowCount","_this$state","scrollbarSize","estimatedTotalHeight","estimatedTotalWidth","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_this$props3","_callPropsCallbacks","componentDidUpdate","_this$state2","componentWillUnmount","render","_this$props4","children","className","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","_this$_getHorizontalR","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_this$_getVerticalRan","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","_rowIndex","_columnIndex","push","WebkitOverflowScrolling","willChange","pointerEvents","_this$props5","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_this$state3","_horizontalScrollDirection","_scrollLeft","_scrollTop","_scrollUpdateWasRequested","_verticalScrollDirection","_this$props6","overscanColumnCount","overscanColumnsCount","overscanCount","_this$state4","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","_this$props7","overscanRowCount","overscanRowsCount","_this$state5","PureComponent","defaultProps","_ref5","_ref6","DEFAULT_ESTIMATED_ITEM_SIZE","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","offset","numUnmeasuredItems","totalSizeOfUnmeasuredItems","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","findNearestItem","lastMeasuredItemOffset","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","_ref6$shouldForceUpda","forceUpdate","_ref7","IS_SCROLLING_DEBOUNCE_INTERVAL$1","defaultItemKey$1","devWarningsDirection","devWarningsTagName$1","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getStartIndexForOffset","getStopIndexForStartIndex","List","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_event$currentTarget2","validateSharedProps$1","_this$props5$itemKey","_this$_getRangeToRend","_getRangeToRender","_index","_this$_getRangeToRend2","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_scrollDirection","_scrollOffset","DEFAULT_ESTIMATED_ITEM_SIZE$1","getItemMetadata$1","findNearestItem$1","findNearestItemBinarySearch$1","findNearestItemExponentialSearch$1","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","_ref8","lastRowOffset","_ref9","_ref10","numVisibleColumns","_ref11","_ref12","numVisibleRows","_ref13","FixedSizeList","lastItemOffset","numVisibleItems","shallowDiffers","prev","next","attribute","_attribute","_excluded","_excluded2","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","shouldComponentUpdate","nextState"],"mappings":"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","file":"9405.982e534fe9113a940f0b.js?v=982e534fe9113a940f0b","sourcesContent":["var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _class;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var _this$props2 = this.props,\n          itemCount = _this$props2.itemCount,\n          layout = _this$props2.layout;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      // This is an edge case for lists; normally they only scroll in the dominant direction.\n\n      var scrollbarSize = 0;\n\n      if (this._outerRef) {\n        var outerRef = this._outerRef;\n\n        if (layout === 'vertical') {\n          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;\n        } else {\n          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;\n        }\n      }\n\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          initialScrollOffset = _this$props3.initialScrollOffset,\n          layout = _this$props3.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props4 = this.props,\n          direction = _this$props4.direction,\n          layout = _this$props4.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props5 = this.props,\n          children = _this$props5.children,\n          className = _this$props5.className,\n          direction = _this$props5.direction,\n          height = _this$props5.height,\n          innerRef = _this$props5.innerRef,\n          innerElementType = _this$props5.innerElementType,\n          innerTagName = _this$props5.innerTagName,\n          itemCount = _this$props5.itemCount,\n          itemData = _this$props5.itemData,\n          _this$props5$itemKey = _this$props5.itemKey,\n          itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey,\n          layout = _this$props5.layout,\n          outerElementType = _this$props5.outerElementType,\n          outerTagName = _this$props5.outerTagName,\n          style = _this$props5.style,\n          useIsScrolling = _this$props5.useIsScrolling,\n          width = _this$props5.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props6 = this.props,\n          itemCount = _this$props6.itemCount,\n          overscanCount = _this$props6.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar _excluded = [\"style\"],\n    _excluded2 = [\"style\"];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n"],"sourceRoot":""}