{"version":3,"file":"tokens.js","sourceRoot":"./@jupyterlab/git/src/","sources":["tokens.ts"],"names":[],"mappings":"AAGA,OAAO,EAAY,gBAAgB,EAAE,MAAM,sBAAsB,CAAC;AAElE,OAAO,EAAkC,KAAK,EAAE,MAAM,mBAAmB,CAAC;AAK1E,MAAM,CAAC,MAAM,YAAY,GAAG,+BAA+B,CAAC;AAE5D,MAAM,CAAC,MAAM,aAAa,GAAG,IAAI,KAAK,CAAgB,YAAY,CAAC,CAAC;AA+iBpE,MAAM,KAAW,GAAG,CA4iBnB;AA5iBD,WAAiB,GAAG;IAClB,IAAiB,IAAI,CA6IpB;IA7ID,WAAiB,IAAI;QAqInB,IAAY,UAOX;QAPD,WAAY,UAAU;YACpB,kBAAkB;YAClB,iDAAS,CAAA;YACT,gBAAgB;YAChB,6CAAO,CAAA;YACP,sDAAsD;YACtD,2CAAM,CAAA;QACR,CAAC,EAPW,UAAU,GAAV,eAAU,KAAV,eAAU,QAOrB;IACH,CAAC,EA7IgB,IAAI,GAAJ,QAAI,KAAJ,QAAI,QA6IpB;IA+WD;;OAEG;IACH,MAAa,gBAAiB,SAAQ,gBAAgB,CAAC,aAAa;QAClE;;WAEG;QACH,YACE,QAAkB,EAClB,OAAO,GAAG,qBAAqB,QAAQ,CAAC,MAAM,IAAI,QAAQ,CAAC,UAAU,EAAE,EACvE,SAAS,GAAG,EAAE,EACd,OAA2B,EAAE;YAE7B,KAAK,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACzB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC,CAAC,2CAA2C;YACvE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QACpB,CAAC;QAED;;WAEG;QACH,IAAI,IAAI;YACN,OAAO,IAAI,CAAC,KAAK,CAAC;QACpB,CAAC;KAQF;IA5BY,oBAAgB,mBA4B5B,CAAA;IACD,MAAa,eAAgB,SAAQ,KAAK;QACxC;YACE,KAAK,CAAC,yBAAyB,CAAC,CAAC;QACnC,CAAC;KACF;IAJY,mBAAe,kBAI3B,CAAA;AAWH,CAAC,EA5iBgB,GAAG,KAAH,GAAG,QA4iBnB;AAED;;GAEG;AACH,MAAM,CAAN,IAAY,KAMX;AAND,WAAY,KAAK;IACf,wCAAY,CAAA;IACZ,kCAAS,CAAA;IACT,wCAAY,CAAA;IACZ,wCAAY,CAAA;IACZ,oCAAU,CAAA;AACZ,CAAC,EANW,KAAK,KAAL,KAAK,QAMhB;AA2BD;;GAEG;AACH,MAAM,CAAN,IAAY,iBAeX;AAfD,WAAY,iBAAiB;IAC3B,2EAAsD,CAAA;IACtD,mDAA8B,CAAA;IAC9B,qDAAgC,CAAA;IAChC,2DAAsC,CAAA;IACtC,yDAAoC,CAAA;IACpC,qDAAgC,CAAA;IAChC,2DAAsC,CAAA;IACtC,uDAAkC,CAAA;IAClC,uDAAkC,CAAA;IAClC,2DAAsC,CAAA;IACtC,qDAAgC,CAAA;IAChC,uEAAkD,CAAA;IAClD,kDAA6B,CAAA;IAC7B,iEAA4C,CAAA;AAC9C,CAAC,EAfW,iBAAiB,KAAjB,iBAAiB,QAe5B;AAED;;GAEG;AACH,MAAM,CAAN,IAAY,UAgBX;AAhBD,WAAY,UAAU;IACpB,8BAAgB,CAAA;IAChB,yDAA2C,CAAA;IAC3C,kCAAoB,CAAA;IACpB,yCAA2B,CAAA;IAC3B,kEAAoD,CAAA;IACpD,uEAAyD,CAAA;IACzD,mDAAqC,CAAA;IACrC,oCAAsB,CAAA;IACtB,oCAAsB,CAAA;IACtB,qDAAuC,CAAA;IACvC,kCAAoB,CAAA;IACpB,kCAAoB,CAAA;IACpB,sDAAwC,CAAA;IACxC,oDAAsC,CAAA;IACtC,2CAA6B,CAAA;AAC/B,CAAC,EAhBW,UAAU,KAAV,UAAU,QAgBrB","sourcesContent":["import { Toolbar } from '@jupyterlab/apputils';\nimport { IChangedArgs } from '@jupyterlab/coreutils';\nimport { DocumentRegistry } from '@jupyterlab/docregistry';\nimport { Contents, ServerConnection } from '@jupyterlab/services';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { JSONObject, ReadonlyJSONObject, Token } from '@lumino/coreutils';\nimport { IDisposable } from '@lumino/disposable';\nimport { ISignal } from '@lumino/signaling';\nimport { Widget } from '@lumino/widgets';\n\nexport const EXTENSION_ID = 'jupyter.extensions.git_plugin';\n\nexport const IGitExtension = new Token<IGitExtension>(EXTENSION_ID);\n\n/** Interface for extension class */\nexport interface IGitExtension extends IDisposable {\n  /**\n   * The list of branch in the current repo\n   */\n  branches: Git.IBranch[];\n\n  /**\n   * The current branch\n   */\n  currentBranch: Git.IBranch;\n\n  /**\n   * A signal emitted when the branches of the Git repository changes.\n   */\n  readonly branchesChanged: ISignal<IGitExtension, void>;\n\n  /**\n   * A signal emitted when the `HEAD` of the Git repository changes.\n   */\n  readonly headChanged: ISignal<IGitExtension, void>;\n\n  /**\n   * Top level path of the current Git repository\n   */\n  pathRepository: string | null;\n\n  /**\n   * A signal emitted when the current Git repository changes.\n   */\n  readonly repositoryChanged: ISignal<IGitExtension, IChangedArgs<string>>;\n\n  /**\n   * Test whether the model is ready;\n   * i.e. if the top folder repository has been found.\n   */\n  isReady: boolean;\n\n  /**\n   * A promise that fulfills when the model is ready;\n   * i.e. if the top folder repository has been found.\n   */\n  ready: Promise<void>;\n\n  /**\n   * Custom model refresh standby condition\n   */\n  refreshStandbyCondition: () => boolean;\n\n  /**\n   * Selected file for single file history\n   */\n  selectedHistoryFile: Git.IStatusFile | null;\n\n  /**\n   * Boolean indicating whether there are dirty staged files\n   * (e.g., due to unsaved changes on files that have been previously staged).\n   */\n  hasDirtyFiles: boolean;\n\n  /**\n   * Boolean indicating whether credentials are required from the user.\n   */\n  credentialsRequired: boolean;\n\n  /**\n   * A signal emitted whenever credentials are required, or are not required anymore.\n   */\n  readonly credentialsRequiredChanged: ISignal<IGitExtension, boolean>;\n\n  /**\n   * Git repository status.\n   */\n  readonly status: Git.IStatus;\n\n  /**\n   * A signal emitted when the current status of the Git repository changes.\n   */\n  readonly statusChanged: ISignal<IGitExtension, Git.IStatus>;\n\n  /**\n   * A signal emitted whenever a model task event occurs.\n   */\n  readonly taskChanged: ISignal<IGitExtension, string>;\n\n  /**\n   * A signal emitted when the current file selected for history of the Git repository changes.\n   */\n  readonly selectedHistoryFileChanged: ISignal<\n    IGitExtension,\n    Git.IStatusFile | null\n  >;\n\n  /**\n   * A signal emitted when files that are behind the remote branch are opened.\n   */\n  readonly notifyRemoteChanges: ISignal<\n    IGitExtension,\n    Git.IRemoteChangedNotification | null\n  >;\n\n  /**\n   * A signal emitted indicating whether there are dirty (e.g., unsaved) staged files.\n   * This signal is emitted when there is a dirty staged file but none in prior,\n   * and vice versa, when there are no dirty staged files but there were previously.\n   */\n  readonly dirtyFilesStatusChanged: ISignal<IGitExtension, boolean>;\n\n  /**\n   * Add one or more files to the repository staging area.\n   *\n   * ## Notes\n   *\n   * -   If no filename is provided, all files are added.\n   *\n   * @param filename - files to add\n   * @returns promise which resolves upon adding files to the repository staging area\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  add(...filename: string[]): Promise<void>;\n\n  /**\n   * Add all \"unstaged\" files to the repository staging area.\n   *\n   * @returns promise which resolves upon adding files to the repository staging area\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  addAllUnstaged(): Promise<void>;\n\n  /**\n   * Add all untracked files to the repository staging area.\n   *\n   * @returns promise which resolves upon adding files to the repository staging area\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  addAllUntracked(): Promise<void>;\n\n  /**\n   * Add the file named fname to the current marker with given mark\n   *\n   * @param fname Filename\n   * @param mark Mark to set\n   */\n  addMark(fname: string, mark: boolean): void;\n\n  /**\n   * Add a remote Git repository to the current repository.\n   *\n   * @param url - remote repository URL\n   * @param name - remote name\n   * @returns promise which resolves upon adding a remote\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  addRemote(url: string, name?: string): Promise<void>;\n\n  /**\n   * Retrieve the repository commit log.\n   *\n   * ## Notes\n   *\n   * -  This API can be used to implicitly check if the current folder is a Git repository.\n   *\n   * @param count - number of commits to retrieve\n   * @returns promise which resolves upon retrieving the repository commit log\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  allHistory(historyCount?: number): Promise<Git.IAllHistory>;\n\n  /**\n   * Checkout a branch.\n   *\n   * ## Notes\n   *\n   * -   If a branch name is provided, checkout the provided branch (with or without creating it)\n   * -   If a filename is provided, checkout the file, discarding all changes.\n   * -   If nothing is provided, checkout all files, discarding all changes.\n   *\n   * TODO: Refactor into separate endpoints for each kind of checkout request\n   *\n   * @param options - checkout options\n   * @returns promise which resolves upon performing a checkout\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  checkout(options?: Git.ICheckoutOptions): Promise<Git.ICheckoutResult>;\n\n  /**\n   * Make request to checkout the specified tag version\n   *\n   * @param tag of the version to checkout\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  checkoutTag(tag: string): Promise<Git.ICheckoutResult>;\n\n  /**\n   * Clone a repository.\n   *\n   * @param path - local path into which the repository will be cloned\n   * @param url - Git repository URL\n   * @param auth - remote repository authentication information\n   * @param versioning - Whether to clone or download the Git repository\n   * @param submodules - Whether to clone recursively the Git submodules\n   * @returns promise which resolves upon cloning a repository\n   *\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  clone(\n    path: string,\n    url: string,\n    auth?: Git.IAuth,\n    versioning?: boolean,\n    submodules?: boolean\n  ): Promise<Git.IResultWithMessage>;\n\n  /**\n   * Commit all staged file changes.\n   *\n   * @param message - commit message\n   * @returns promise which resolves upon committing file changes\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  commit(message: string): Promise<void>;\n\n  /**\n   * Get (or set) Git configuration options.\n   *\n   * @param options - configuration options to set\n   * @returns promise which resolves upon either getting or setting configuration options\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  config(options?: JSONObject): Promise<JSONObject | void>;\n\n  /**\n   * Delete a branch\n   *\n   * @param branchName Branch name\n   * @returns promise which resolves when the branch has been deleted.\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  deleteBranch(branchName: string): Promise<void>;\n\n  /**\n   * Fetch commit information.\n   *\n   * @param hash - commit hash\n   * @returns promise which resolves upon retrieving commit information\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  detailedLog(hash: string): Promise<Git.ISingleCommitFilePathInfo>;\n\n  /**\n   * Get the diff of two commits.\n   * If no commit is provided, the diff of HEAD and INDEX is returned.\n   * If the current commit (the commit to compare) is not provided,\n   * the diff of the previous commit and INDEX is returned.\n   *\n   * @param previous - the commit to compare against\n   * @param current - the commit to compare\n   * @returns promise which resolves upon retrieving the diff\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  diff(previous?: string, current?: string): Promise<Git.IDiffResult>;\n\n  /**\n   * Ensure a .gitignore file exists\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  ensureGitignore(): Promise<void>;\n\n  /**\n   * Fetch to get ahead/behind status\n   *\n   * @param auth - remote authentication information\n   * @returns promise which resolves upon fetching\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  fetch(auth?: Git.IAuth): Promise<Git.IResultWithMessage>;\n\n  /**\n   * Match files status information based on a provided file path.\n   *\n   * If the file is tracked and has no changes, a StatusFile of unmodified will be returned\n   *\n   * @param path the file path relative to the server root\n   */\n  getFile(path: string): Git.IStatusFile;\n\n  /**\n   * Get current mark of file named fname\n   *\n   * @param fname Filename\n   * @returns Mark of the file\n   */\n  getMark(fname: string): boolean;\n\n  /**\n   * Gets the path of the file relative to the Jupyter server root.\n   *\n   * If no path is provided, returns the Git repository top folder relative path.\n   * If no Git repository selected, return null\n   *\n   * @param path the file path relative to Git repository top folder\n   * @returns Relative file path to the server root\n   */\n  getRelativeFilePath(path?: string): string | null;\n\n  /**\n   * Add an entry in .gitignore file\n   *\n   * @param filename The name of the entry to ignore\n   * @param useExtension Ignore all files having the same extension as filename\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  ignore(filename: string, useExtension: boolean): Promise<void>;\n\n  /**\n   * Initialize a new Git repository at a specified path.\n   *\n   * @param path - path at which initialize a Git repository\n   * @returns promise which resolves upon initializing a Git repository\n   *\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  init(path: string): Promise<void>;\n\n  /**\n   * Retrieve commit logs.\n   *\n   * @param count - number of commits\n   * @returns promise which resolves upon retrieving commit logs\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  log(historyCount?: number): Promise<Git.ILogResult>;\n\n  /**\n   * Merge the given branch with the current one.\n   *\n   * @param branch to merge into the current branch\n   * @returns promise which resolves upon merge action\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  merge(branch: string): Promise<Git.IResultWithMessage>;\n\n  /**\n   * Fetch changes from a remote repository.\n   *\n   * @param auth - remote authentication information\n   * @returns promise which resolves upon fetching changes\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  pull(auth?: Git.IAuth): Promise<Git.IResultWithMessage>;\n\n  /**\n   * Push local changes to a remote repository.\n   *\n   * @param auth - remote authentication information\n   * @param force - whether or not to force the push\n   * @returns promise which resolves upon pushing changes\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  push(\n    auth?: Git.IAuth,\n    force?: boolean,\n    remote?: string\n  ): Promise<Git.IResultWithMessage>;\n\n  /**\n   * General Git refresh\n   */\n  refresh(): Promise<void>;\n\n  /**\n   * Make request for a list of all Git branches\n   */\n  refreshBranch(): Promise<void>;\n\n  /**\n   * Determines whether there are unsaved changes on staged files,\n   * e.g., the user has made changes to a file that has been staged,\n   * but has not saved them.\n   * Emits a signal indicating if there are unsaved changes.\n   * @returns promise that resolves upon refreshing the dirty status of staged files\n   */\n  refreshDirtyStatus(): Promise<void>;\n\n  /**\n   * Request Git status refresh\n   */\n  refreshStatus(): Promise<void>;\n\n  /**\n   * gets a list of files that have changed in the remote branch\n   */\n  remoteChangedFiles(): Promise<Git.IStatusFile[]>;\n\n  /**\n   * Notifies user is a file that is attached has is behind changes in the remote branch with a pop-up Dialog\n   */\n  checkRemoteChangeNotified(): Promise<void>;\n\n  /**\n   * Register a new diff provider for specified file types\n   *\n   * @param name provider name\n   * @param fileExtensions File extensions list\n   * @param callback Callback to use for the provided file types\n   */\n  registerDiffProvider(\n    name: string,\n    fileExtensions: string[],\n    callback: Git.Diff.ICallback\n  ): void;\n\n  /**\n   * Move files from the \"staged\" to the \"unstaged\" area.\n   *\n   * ## Notes\n   *\n   * -  If no filename is provided, moves all files from the \"staged\" to the \"unstaged\" area.\n   *\n   * @param filename - file path to be reset\n   * @returns promise which resolves upon moving files\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  reset(filename?: string): Promise<void>;\n\n  /**\n   * Reset the repository to a specified commit.\n   *\n   * ## Notes\n   *\n   * -   If a commit hash is not provided, resets the repository to `HEAD`.\n   *\n   * @param hash - commit identifier (hash)\n   * @returns promises which resolves upon resetting the repository\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  resetToCommit(hash: string): Promise<void>;\n\n  /**\n   * Revert changes made after a specified commit.\n   *\n   * @param message - commit message\n   * @param hash - commit identifier (hash)\n   * @returns promise which resolves upon reverting changes\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  revertCommit(message: string, hash: string): Promise<void>;\n\n  /**\n   * Get the prefix path of a directory 'path',\n   * with respect to the root directory of repository\n   *\n   * @param path Path for which the prefix is searched for\n   * @returns Path prefix\n   *\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  showPrefix(path: string): Promise<string | null>;\n\n  /**\n   * Get the top level path of repository 'path'\n   *\n   * @param path Path from which the top Git repository needs to be found\n   *\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  showTopLevel(path: string): Promise<string | null>;\n\n  /**\n   * Make request to list all the tags present in the remote repo\n   *\n   * @returns list of tags\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  tags(): Promise<Git.ITagResult>;\n\n  /**\n   * Toggle the mark for the file named fname\n   *\n   * @param fname Filename\n   */\n  toggleMark(fname: string): void;\n}\n\nexport namespace Git {\n  export namespace Diff {\n    /**\n     * Diff widget interface\n     */\n    export interface IDiffWidget extends Widget {\n      /**\n       * Diff model\n       */\n      readonly model: Git.Diff.IModel;\n      /**\n       * Gets the file model of a resolved merge conflict,\n       * and rejects if unable to retrieve\n       */\n      getResolvedFile(): Promise<Partial<Contents.IModel>>;\n      /**\n       * Checks if the conflicted file has been resolved.\n       */\n      readonly isFileResolved: boolean;\n      /**\n       * Refresh the diff widget\n       *\n       * Note: Update the content and recompute the diff\n       */\n      refresh(): Promise<void>;\n    }\n\n    /**\n     * Callback to generate a comparison widget\n     *\n     * The toolbar is the one of the MainAreaWidget in which the diff widget\n     * will be displayed.\n     */\n    export type ICallback = (\n      model: IModel,\n      toolbar?: Toolbar,\n      trans?: ITranslator\n    ) => Promise<IDiffWidget>;\n\n    /**\n     * Content and its context for diff\n     */\n    export interface IContent {\n      /**\n       * Asynchronous content getter for the source\n       */\n      content: () => Promise<string>;\n      /**\n       * Content label\n       *\n       * Note: It is the preferred displayed information\n       */\n      label: string;\n      /**\n       * Source of the content\n       *\n       * Note: It is a machine friendly reference\n       */\n      source: any;\n      /**\n       * Last time at which the content was updated.\n       *\n       * Optional, can be useful to trigger model changed signal\n       */\n      updateAt?: number;\n    }\n\n    /**\n     * Model which indicates the context in which a Git diff is being performed.\n     *\n     * It can be:\n     * - a regular Git ref, i.e, https://git-scm.com/book/en/v2/Git-Internals-Git-References\n     * - special/reserved references\n     *\n     * 1. WORKING: The Working Tree\n     * 2. INDEX: The Staging Area\n     *\n     * To differentiate with the regular Git ref they are passed as number\n     */\n    export interface IContext {\n      currentRef: string | SpecialRef.WORKING | SpecialRef.INDEX;\n      previousRef: string | SpecialRef;\n      // Used only during merge conflict diffs\n      baseRef?: string | SpecialRef.BASE;\n    }\n\n    /**\n     * DiffModel properties\n     */\n    export interface IModel {\n      /**\n       * Challenger data\n       */\n      challenger: IContent;\n      /**\n       * Signal emitted when the reference or the challenger changes\n       */\n      readonly changed: ISignal<IModel, IModelChange>;\n      /**\n       * File of the name being diff at reference state\n       *\n       * Note: This is the relative path\n       */\n      readonly filename: string;\n      /**\n       * Reference data\n       */\n      reference: IContent;\n      /**\n       * Optional base data, used only during merge conflicts\n       */\n      base?: IContent;\n      /**\n       * Helper to check if the file has conflicts.\n       */\n      hasConflict?: boolean;\n      /**\n       * Git repository path\n       *\n       * Note: This is relative to the server root\n       */\n      readonly repositoryPath?: string;\n    }\n\n    /**\n     * DiffModel changed signal argument\n     */\n    export interface IModelChange {\n      /**\n       * Which content did change\n       */\n      type: 'reference' | 'challenger' | 'base';\n    }\n\n    export enum SpecialRef {\n      // Working version\n      'WORKING',\n      // Index version\n      'INDEX',\n      // Common ancestor version (useful for unmerged files)\n      'BASE'\n    }\n  }\n\n  /**\n   * Interface for GitAllHistory request result,\n   * has all repo information\n   */\n  export interface IAllHistory {\n    code: number;\n    data?: {\n      show_top_level?: IShowTopLevelResult;\n      branch?: IBranchResult;\n      log?: ILogResult;\n      status?: IStatusResult;\n    };\n  }\n\n  /**\n   * Interface for server settings\n   */\n  export interface IServerSettings {\n    /**\n     * Frontend version formatted as Python package version\n     */\n    frontendVersion?: string;\n    /**\n     * Git version (X.Y.Z)\n     */\n    gitVersion?: string;\n    /**\n     * Server extension version formatted as Python package version\n     */\n    serverVersion: string;\n  }\n\n  /**\n   * Interface for GitShowTopLevel request result,\n   * has the Git root directory inside a repository\n   */\n  export interface IShowTopLevelResult {\n    /**\n     * Git command return code\n     */\n    code: number;\n    /**\n     * Git repository root path\n     */\n    path?: string;\n  }\n\n  /**\n   * Interface for GitShowPrefix request result,\n   * has the prefix path of a directory in a repository,\n   * with respect to the root directory.\n   */\n  export interface IShowPrefixResult {\n    /**\n     * Git command return code\n     */\n    code: number;\n    /**\n     * Relative path of the current folder within its Git repository\n     */\n    path?: string;\n  }\n\n  /**\n   * Interface to call the checkout method\n   *\n   * If a branch name is provided, check it out (with or without creating it)\n   * If a filename is provided, check the file out\n   * If nothing is provided, check all files out\n   */\n  export interface ICheckoutOptions {\n    /**\n     * Branch name\n     */\n    branchname?: string;\n    /**\n     * Is it a new branch?\n     */\n    newBranch?: boolean;\n    /**\n     * The commit (branch name, tag, or commit id) to which a new branch HEAD will point.\n     */\n    startpoint?: string;\n    /**\n     * Filename\n     */\n    filename?: string;\n  }\n\n  /** Interface for GitCheckout request result.\n   * For reporting errors in checkout\n   */\n  export interface ICheckoutResult {\n    code: number;\n    message?: string;\n  }\n\n  /**\n   * Branch description interface\n   */\n  export interface IBranch {\n    is_current_branch: boolean;\n    is_remote_branch: boolean;\n    name: string;\n    upstream: string | null;\n    top_commit: string;\n    tag: string | null;\n  }\n\n  /** Interface for GitBranch request result,\n   * has the result of fetching info on all branches\n   */\n  export interface IBranchResult {\n    code: number;\n    branches?: IBranch[];\n    current_branch?: IBranch;\n  }\n\n  /**\n   * Data interface of diffcontent request\n   */\n  export interface IDiffContent {\n    /**\n     * File content\n     */\n    content: string;\n  }\n\n  /**\n   * Interface for GitDiff request result\n   */\n  export interface IDiffResult {\n    code: number;\n    command?: string;\n    message?: string;\n    result?: {\n      insertions: string;\n      deletions: string;\n      filename: string;\n      filetype?: DocumentRegistry.IFileType;\n    }[];\n  }\n\n  /**\n   * Git repository status\n   */\n  export interface IStatus {\n    /**\n     * Current branch\n     */\n    branch: string | null;\n    /**\n     * Tracked upstream branch\n     */\n    remote: string | null;\n    /**\n     * Number of commits ahead\n     */\n    ahead: number;\n    /**\n     * Number of commits behind\n     */\n    behind: number;\n    /**\n     * Files status\n     */\n    files: IStatusFile[];\n  }\n\n  /** Interface for GitStatus request result,\n   * has the status of each changed file\n   */\n  export interface IStatusFileResult {\n    x: string;\n    y: string;\n    to: string;\n    from: string;\n    is_binary: boolean | null;\n    // filetype as determined by app.docRegistry\n    type?: DocumentRegistry.IFileType;\n  }\n\n  /**\n   * Changed file attributes\n   */\n  export interface IStatusFile extends IStatusFileResult {\n    status: Status;\n  }\n\n  /** Interface for GitStatus request result,\n   * has the status of the entire repo\n   */\n  export interface IStatusResult {\n    code: number;\n    branch?: string;\n    remote?: string | null;\n    ahead?: number;\n    behind?: number;\n    files?: IStatusFileResult[];\n  }\n\n  /** Interface for changed_files request result\n   * lists the names of files that have differences between two commits\n   * or between two branches, or that were changed by a single commit\n   */\n  export interface IChangedFilesResult {\n    code: number;\n    files?: string[];\n  }\n\n  /** Interface for notifying users of opened files that are behind\n   * the remote branch\n   */\n  export interface IRemoteChangedNotification {\n    notNotified: IStatusFile[];\n    notified: IStatusFile[];\n  }\n\n  /** Interface for GitLog request result,\n   * has the info of a single past commit\n   */\n  export interface ISingleCommitInfo {\n    commit: string;\n    author: string;\n    date: string;\n    commit_msg: string;\n    pre_commits: string[];\n\n    // properties for single file history\n    is_binary?: boolean;\n    file_path?: string;\n\n    // when file has been relocated\n    previous_file_path?: string;\n  }\n\n  /** Interface for GitCommit request result,\n   * has the info of a committed file\n   */\n  export interface ICommitModifiedFile {\n    modified_file_path: string;\n    modified_file_name: string;\n    insertion: string;\n    deletion: string;\n    is_binary: boolean | null;\n    // filetype as determined by app.docRegistry\n    type?: DocumentRegistry.IFileType;\n    // when file has been relocated\n    previous_file_path?: string;\n  }\n\n  /** Interface for GitDetailedLog request result,\n   * has the detailed info of a single past commit\n   */\n  export interface ISingleCommitFilePathInfo {\n    code: number;\n    commit_body?: string;\n    modified_file_note?: string;\n    modified_files_count?: string;\n    number_of_insertions?: string;\n    number_of_deletions?: string;\n    modified_files?: ICommitModifiedFile[];\n  }\n\n  /** Interface for GitLog request result,\n   * has the info of all past commits\n   */\n  export interface ILogResult {\n    code: number;\n    commits?: ISingleCommitInfo[];\n  }\n\n  export interface IIdentity {\n    name: string;\n    email: string;\n  }\n\n  /**\n   * Interface for the Git Auth request with credentials caching option.\n   */\n  export interface IAuth {\n    username: string;\n    password: string;\n    cache_credentials?: boolean;\n  }\n\n  /**\n   * Structure for the request to the Git Remote Add API.\n   */\n  export interface IGitRemote {\n    url: string;\n    name: string;\n  }\n\n  /**\n   * Interface for GitRemoteShowDetails request result,\n   * has the name and urls of all remotes\n   */\n  export interface IGitRemoteResult {\n    code: number;\n    command: string;\n    remotes: Git.IGitRemote[];\n  }\n\n  /**\n   * Structure for the request to the Git Clone API.\n   */\n  export interface IGitClone {\n    current_path: string;\n    clone_url: string;\n    auth?: IAuth;\n  }\n\n  /**\n   * Structure for the request to the Git Clone API.\n   */\n  export interface IPushPull {\n    current_path: string;\n    auth?: IAuth;\n    cancel_on_conflict?: boolean;\n  }\n\n  /**\n   * Structure for commands with informative output\n   */\n  export interface IResultWithMessage {\n    /**\n     * Git process return code\n     */\n    code: number;\n    /**\n     * Git process result message\n     */\n    message: string;\n  }\n\n  /**\n   * Interface for a marker obj\n   */\n  export interface IBranchMarker {\n    add(fname: string, mark: boolean): void;\n\n    get(fname: string): boolean;\n\n    set(fname: string, mark: boolean): void;\n\n    toggle(fname: string): void;\n  }\n\n  export type Status =\n    | 'untracked'\n    | 'staged'\n    | 'unstaged'\n    | 'partially-staged'\n    | 'remote-changed'\n    | 'unmodified'\n    | 'unmerged'\n    | null;\n\n  export interface ITagResult {\n    code: number;\n    message?: string;\n    tags?: string[];\n  }\n\n  /**\n   * A wrapped error for a fetch response.\n   */\n  export class GitResponseError extends ServerConnection.ResponseError {\n    /**\n     * Create a new response error.\n     */\n    constructor(\n      response: Response,\n      message = `Invalid response: ${response.status} ${response.statusText}`,\n      traceback = '',\n      json: ReadonlyJSONObject = {}\n    ) {\n      super(response, message);\n      this.traceback = traceback; // traceback added in mother class in 2.2.x\n      this._json = json;\n    }\n\n    /**\n     * The error response JSON body\n     */\n    get json(): ReadonlyJSONObject {\n      return this._json;\n    }\n\n    /**\n     * The traceback associated with the error.\n     */\n    traceback: string;\n\n    protected _json: ReadonlyJSONObject;\n  }\n  export class NotInRepository extends Error {\n    constructor() {\n      super('Not in a Git Repository');\n    }\n  }\n\n  /**\n   * Interface for dialog with one checkbox.\n   */\n  export interface ICheckboxFormValue {\n    /**\n     * Checkbox value\n     */\n    checked: boolean;\n  }\n}\n\n/**\n * Log message severity.\n */\nexport enum Level {\n  SUCCESS = 10,\n  INFO = 20,\n  RUNNING = 30,\n  WARNING = 40,\n  ERROR = 50\n}\n\n/**\n * Interface describing a component log message.\n */\nexport interface ILogMessage {\n  /**\n   * Detailed message\n   */\n  details?: string;\n\n  /**\n   * Error object.\n   */\n  error?: Error;\n\n  /**\n   * Message level.\n   */\n  level: Level;\n\n  /**\n   * Message text.\n   */\n  message: string;\n}\n\n/**\n * The command IDs used in the git context menus.\n */\nexport enum ContextCommandIDs {\n  gitCommitAmendStaged = 'git:context-commitAmendStaged',\n  gitFileAdd = 'git:context-add',\n  gitFileDiff = 'git:context-diff',\n  gitFileDiscard = 'git:context-discard',\n  gitFileDelete = 'git:context-delete',\n  gitFileOpen = 'git:context-open',\n  gitFileUnstage = 'git:context-unstage',\n  gitFileStage = 'git:context-stage',\n  gitFileTrack = 'git:context-track',\n  gitFileHistory = 'git:context-history',\n  gitIgnore = 'git:context-ignore',\n  gitIgnoreExtension = 'git:context-ignoreExtension',\n  gitNoAction = 'git:no-action',\n  openFileFromDiff = 'git:open-file-from-diff'\n}\n\n/**\n * The command IDs used by the git plugin.\n */\nexport enum CommandIDs {\n  gitUI = 'git:ui',\n  gitTerminalCommand = 'git:terminal-command',\n  gitInit = 'git:init',\n  gitOpenUrl = 'git:open-url',\n  gitToggleSimpleStaging = 'git:toggle-simple-staging',\n  gitToggleDoubleClickDiff = 'git:toggle-double-click-diff',\n  gitManageRemote = 'git:manage-remote',\n  gitClone = 'git:clone',\n  gitMerge = 'git:merge',\n  gitOpenGitignore = 'git:open-gitignore',\n  gitPush = 'git:push',\n  gitPull = 'git:pull',\n  gitResetToRemote = 'git:reset-to-remote',\n  gitSubmitCommand = 'git:submit-commit',\n  gitShowDiff = 'git:show-diff'\n}\n"]}