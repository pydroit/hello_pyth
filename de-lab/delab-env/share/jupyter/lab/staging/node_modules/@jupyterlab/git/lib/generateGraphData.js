const Node = (sha, offset, branch, routes, yOffset) => ({
    sha,
    dot: { lateralOffset: offset, branch },
    routes,
    yOffset
});
function remove(list, item) {
    list.splice(list.indexOf(item), 1);
    return list;
}
/**
 * Generate graph data.
 * @param commits a list of commit, which should have `sha`, `parents` properties.
 * @param getNodeHeight a callback to retrieve the height of the history node
 * @returns data nodes, a json list of
      [
        {
          sha,
          {offset, branch}, //dot
          [
            {from, to, branch},  // route 1
            {from, to, branch},  // route 2
            {from, to, branch},
          ] // routes
        } // node
      ],
 */
export function generateGraphData(commits, getNodeHeight) {
    const nodes = [];
    const branchIndex = [0];
    const reserve = [];
    const branches = {};
    function getBranch(sha) {
        if (branches[sha] === null || branches[sha] === undefined) {
            branches[sha] = branchIndex[0];
            reserve.push(branchIndex[0]);
            branchIndex[0]++;
        }
        return branches[sha];
    }
    let currentYOffset = 25;
    commits.forEach((commit, index) => {
        let b, i;
        const branch = getBranch(commit.sha);
        const numParents = commit.parents.length;
        const offset = reserve.indexOf(branch);
        const routes = [];
        if (numParents === 1) {
            if (branches[commit.parents[0]] || branches[commit.parents[0]] === 0) {
                // create branch
                const iterable = reserve.slice(offset + 1);
                for (i = 0; i < iterable.length; i++) {
                    b = iterable[i];
                    routes.push({
                        from: i + offset + 1,
                        to: i + offset + 1 - 1,
                        branch: b
                    });
                }
                const iterable1 = reserve.slice(0, offset);
                for (i = 0; i < iterable1.length; i++) {
                    b = iterable1[i];
                    routes.push({ from: i, to: i, branch: b });
                }
                remove(reserve, branch);
                routes.push({
                    from: offset,
                    to: reserve.indexOf(branches[commit.parents[0]]),
                    branch
                });
            }
            else {
                // straight
                for (i = 0; i < reserve.length; i++) {
                    b = reserve[i];
                    routes.push({ from: i, to: i, branch: b });
                }
                branches[commit.parents[0]] = branch;
            }
        }
        else if (numParents === 2) {
            // merge branch
            branches[commit.parents[0]] = branch;
            for (i = 0; i < reserve.length; i++) {
                b = reserve[i];
                routes.push({ from: i, to: i, branch: b });
            }
            const otherBranch = getBranch(commit.parents[1]);
            routes.push({
                from: offset,
                to: reserve.indexOf(otherBranch),
                branch: otherBranch
            });
        }
        if (index - 1 >= 0) {
            currentYOffset += getNodeHeight(commits[index - 1].sha);
        }
        const node = Node(commit.sha, offset, branch, routes, currentYOffset);
        nodes.push(node);
    });
    return nodes;
}
//# sourceMappingURL=generateGraphData.js.map