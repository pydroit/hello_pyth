{"version":3,"file":"taskhandler.js","sourceRoot":"./@jupyterlab/git/src/","sources":["taskhandler.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,qBAAqB,CAAC;AACjD,OAAO,EAAE,IAAI,EAAE,MAAM,mBAAmB,CAAC;AAEzC,OAAO,EAAW,MAAM,EAAE,MAAM,mBAAmB,CAAC;AAEpD;;GAEG;AACH,MAAM,OAAO,WAAW;IACtB,YAAY,KAAQ;QAqHZ,gBAAW,GAAG,KAAK,CAAC;QAEpB,cAAS,GAAoB,IAAI,UAAU,EAAE,CAAC;QAtHpD,IAAI,CAAC,YAAY,GAAG,IAAI,MAAM,CAAY,KAAK,CAAC,CAAC;IACnD,CAAC;IAED;;OAEG;IACH,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED;;;;OAIG;IACH,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED;;;;;;;;;;;OAWG;IACH,GAAG,CAAC,IAAY;QACd,qCAAqC;QACrC,MAAM,EAAE,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QAElC,6CAA6C;QAC7C,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;YACrB,EAAE,EAAE,EAAE;YACN,IAAI,EAAE,IAAI;SACX,CAAC,CAAC;QAEH,uDAAuD;QACvD,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC9B;QACD,mFAAmF;QACnF,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;OAEG;IACH,OAAO;QACL,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,OAAO;SACR;QACD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QACxB,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACzB,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,OAAO,CAAI,IAAY,EAAE,QAA0B;QACvD,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAI;YACF,OAAO,MAAM,QAAQ,EAAE,CAAC;SACzB;gBAAS;YACR,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SACrB;IACH,CAAC;IAED;;;;OAIG;IACH,MAAM,CAAC,MAAc;QACnB,IAAI,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;QAEpC,0BAA0B;QAC1B,IAAI,CAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,KAAK,CAAC,EAAE,MAAK,MAAM,EAAE;YAC7B,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;SACjC;aAAM;YACL,wEAAwE;YACxE,OAAO,IAAI,CAAC,IAAI,EAAE;gBAChB,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;gBACjB,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,KAAK,MAAM,EAAE;oBAC1C,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;oBAChC,MAAM;iBACP;aACF;SACF;QAED,mEAAmE;QACnE,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SACjC;aAAM;YACL,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SACnD;IACH,CAAC;IAED;;;;OAIG;IACK,eAAe;QACrB,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC;IACtB,CAAC;CAKF","sourcesContent":["import { LinkedList } from '@lumino/collections';\nimport { UUID } from '@lumino/coreutils';\nimport { IDisposable } from '@lumino/disposable';\nimport { ISignal, Signal } from '@lumino/signaling';\n\n/**\n * A generic task handler\n */\nexport class TaskHandler<T> implements IDisposable {\n  constructor(model: T) {\n    this._taskChanged = new Signal<T, string>(model);\n  }\n\n  /**\n   * Boolean indicating whether the handler has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Signal emitted when a task starts\n   *\n   * 'empty' is emitted each time the task list have processed all tasks\n   */\n  get taskChanged(): ISignal<T, string> {\n    return this._taskChanged;\n  }\n\n  /**\n   * Adds a task to the list of pending model tasks.\n   *\n   * #Note:\n   *  This will add a task name in the queue but the task\n   *  execution remains in the hand of the caller.\n   *  In particular it is the responsibility of the caller\n   *  to call `remove(taskID)` when the task is executed.\n   *\n   * @param task - task name\n   * @returns task identifier\n   */\n  add(task: string): string {\n    // Generate a unique task identifier:\n    const id = this._generateTaskID();\n\n    // Add the task to our list of pending tasks:\n    this._taskList.addLast({\n      id: id,\n      task: task\n    });\n\n    // If this task is the only task, broadcast the task...\n    if (this._taskList.length === 1) {\n      this._taskChanged.emit(task);\n    }\n    // Return the task identifier to allow consumers to remove the task once completed:\n    return id;\n  }\n\n  /**\n   * Dispose of task handler.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    Signal.clearData(this);\n  }\n\n  /**\n   * Add a asynchronous task to the stack and execute it\n   *\n   * @param name Name of the task\n   * @param callable Asynchronous task to be executed\n   *\n   * @returns The result of the task\n   */\n  async execute<R>(name: string, callable: () => Promise<R>): Promise<R> {\n    const taskID = this.add(name);\n    try {\n      return await callable();\n    } finally {\n      this.remove(taskID);\n    }\n  }\n\n  /**\n   * Removes a task from the list of pending model tasks.\n   *\n   * @param id - task identifier\n   */\n  remove(taskID: string): void {\n    let node = this._taskList.firstNode;\n\n    // Check the first node...\n    if (node?.value.id === taskID) {\n      this._taskList.removeNode(node);\n    } else {\n      // Walk the task list looking for a task with the provided identifier...\n      while (node.next) {\n        node = node.next;\n        if (node.value && node.value.id === taskID) {\n          this._taskList.removeNode(node);\n          break;\n        }\n      }\n    }\n\n    // Check for pending tasks and broadcast the oldest pending task...\n    if (this._taskList.length === 0) {\n      this._taskChanged.emit('empty');\n    } else {\n      this._taskChanged.emit(this._taskList.first.task);\n    }\n  }\n\n  /**\n   * Generates a unique task identifier.\n   *\n   * @returns task identifier\n   */\n  private _generateTaskID(): string {\n    return UUID.uuid4();\n  }\n\n  private _isDisposed = false;\n  private _taskChanged: Signal<T, string>;\n  private _taskList: LinkedList<any> = new LinkedList();\n}\n"]}